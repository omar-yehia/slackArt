<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slack Emoji Art Generator (Ultimate)</title>
    <style>
        :root {
                --grid-rows: 8; 
                --grid-cols: 12;
                --cell-dimension: 30px;
                --empty-color: #f8f8f8;
                --grid-border-color: #ccc;
                /* Define colors for visual drawing feedback (7 Slots) */
                --color-1: #E01E5A; /* Red */
                --color-2: #36C5F0; /* Blue */
                --color-3: #9F401A; /* Brown */
                --color-4: #2EBD59; /* Green */
                --color-5: #6E3F9B; /* Purple */
                --color-6: #F4D338; /* Yellow */
                --color-7: #F26723; /* Orange */
            }

            /* ... other CSS ... */

            /* Color Swatch Indicators */
            .swatch {
                width: 15px;
                height: 15px;
                border-radius: 50%;
                border: 1px solid #333;
            }
            
            .swatch-1 { background-color: var(--color-1); }
            .swatch-2 { background-color: var(--color-2); }
            .swatch-3 { background-color: var(--color-3); }
            .swatch-4 { background-color: var(--color-4); }
            .swatch-5 { background-color: var(--color-5); }
            .swatch-6 { background-color: var(--color-6); }
            .swatch-7 { background-color: var(--color-7); }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 20px;
            background-color: #ffffff;
            color: #2c2d2f;
        }

        .container {
            max-width: 1000px; 
            margin: 0 auto;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        h1 {
            color: #4A154B;
            text-align: center;
        }

        /* --- Controls --- */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px 25px; 
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
            align-items: flex-start; 
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .emoji-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 5px 0;
        }
        
        .emoji-input-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            width: 100px; 
            text-align: center;
        }
        
        .size-inputs input[type="number"] {
            width: 60px; 
        }
        
        /* Disable manual editing of size inputs when drag resize is active */
        .controls.resizing input[type="number"] {
            background-color: #eee;
            pointer-events: none;
        }

        button {
            padding: 10px 15px;
            background-color: #2eb67d; 
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
            height: 38px;
        }

        button:hover {
            background-color: #25a46e;
        }
        
        /* Tool Selector Buttons */
        #tool-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 150px;
        }
        
        .tool-button {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            background-color: #f0f0f0;
            color: #333;
            border: 2px solid #ddd;
            padding: 8px;
            box-sizing: border-box;
        }
        
        .tool-button.active {
            border-color: var(--color-1); 
            background-color: #e6f7f0;
            font-weight: bold;
        }
        
      


        /* --- Grid & Resizer --- */
        #grid-wrapper {
            position: relative; 
            max-width: fit-content;
            margin-bottom: 20px;
            /* Added margin to prevent handles from overlapping other content */
            padding: 15px; 
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), var(--cell-dimension));
            grid-template-rows: repeat(var(--grid-rows), var(--cell-dimension));
            gap: 1px;
            border: 1px solid var(--grid-border-color);
            background-color: var(--grid-border-color);
            user-select: none;
            cursor: crosshair;
        }

        .cell {
            width: var(--cell-dimension);
            height: var(--cell-dimension);
            background-color: var(--empty-color);
            transition: background-color 0.1s;
        }

        /* Dynamic classes for visual selection */
        .cell[data-color-slot="1"] { background-color: var(--color-1); }
        .cell[data-color-slot="2"] { background-color: var(--color-2); }
        .cell[data-color-slot="3"] { background-color: var(--color-3); }
        .cell[data-color-slot="4"] { background-color: var(--color-4); }
        .cell[data-color-slot="5"] { background-color: var(--color-5); }
        .cell[data-color-slot="6"] { background-color: var(--color-6); }
        .cell[data-color-slot="7"] { background-color: var(--color-7); }
        
        /* Resize Handles */
        .resize-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #36c5f0; 
            border-radius: 4px;
            z-index: 10;
        }
        
        #resize-br { /* Bottom-Right */
            bottom: 0px; 
            right: 0px;
            cursor: nwse-resize; 
        }

        #resize-tl { /* Top-Left */
            top: 0px;
            left: 0px;
            cursor: nwse-resize;
        }

        /* --- Output --- */
        #output-area {
            margin-top: 20px;
        }

        #slack-message-output {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre; 
            box-sizing: border-box;
        }

        .copy-button {
            background-color: #36c5f0; 
            margin-top: 10px;
        }
        
        .clear-button {
            background-color: #f03636; 
        }
        .clear-button:hover {
            background-color: #d82e2e;
        }

        .paste-button {
            background-color: #e0b400; /* Yellowish for paste */
        }
        .paste-button:hover {
            background-color: #c79f00;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>ðŸŽ¨ Ultimate Slack Emoji Art Generator</h1>
    <p>Select an **Emoji Slot** to draw. Drag the **blue corner handles** to resize the canvas.</p>

    <div class="controls">
        <div class="control-group size-inputs">
            <label for="row-size">Rows</label>
            <input type="number" id="row-size" value="8" min="3" max="50" onchange="generateGrid()">
            <label for="col-size" style="margin-top: 5px;">Columns</label>
            <input type="number" id="col-size" value="12" min="3" max="50" onchange="generateGrid()">
        </div>

     <div class="control-group">
        <label>Emoji Codes</label>
        <div class="emoji-inputs">
            <div class="emoji-input-row">
                <span class="swatch swatch-1"></span>
                <input type="text" id="filled-emoji-1" value=":large_red_square:" placeholder=":emoji_1: (Red)">
            </div>
            <div class="emoji-input-row">
                <span class="swatch swatch-2"></span>
                <input type="text" id="filled-emoji-2" value=":large_blue_square:" placeholder=":emoji_2: (Blue)">
            </div>
            <div class="emoji-input-row">
                <span class="swatch swatch-3"></span>
                <input type="text" id="filled-emoji-3" value=":large_brown_square:" placeholder=":emoji_3: (Brown)">
            </div>
            <div class="emoji-input-row">
                <span class="swatch swatch-4"></span>
                <input type="text" id="filled-emoji-4" value=":large_green_square:" placeholder=":emoji_4: (Green)">
            </div>
            <div class="emoji-input-row">
                <span class="swatch swatch-5"></span>
                <input type="text" id="filled-emoji-5" value=":large_purple_square:" placeholder=":emoji_5: (Purple)">
            </div>
            <div class="emoji-input-row">
                <span class="swatch swatch-6"></span>
                <input type="text" id="filled-emoji-6" value=":large_yellow_square:" placeholder=":emoji_6: (Yellow)">
            </div>
            <div class="emoji-input-row">
                <span class="swatch swatch-7"></span>
                <input type="text" id="filled-emoji-7" value=":large_orange_square:" placeholder=":emoji_7: (Orange)">
            </div>
            <div class="emoji-input-row">
                <label style="margin: 0; font-weight: normal; min-width: 50px;">Empty:</label>
                <input type="text" id="empty-emoji" value=":white_square:" placeholder=":blank_emoji:">
            </div>
        </div>  
    </div>

    <div class="control-group" id="tool-selector">
        <label>Drawing Tool</label>
        <button class="tool-button active" data-tool="1">
            <span class="swatch swatch-1"></span> Draw Slot 1 (Red)
        </button>
        <button class="tool-button" data-tool="2">
            <span class="swatch swatch-2"></span> Draw Slot 2 (Blue)
        </button>
        <button class="tool-button" data-tool="3">
            <span class="swatch swatch-3"></span> Draw Slot 3 (Brown)
        </button>
        <button class="tool-button" data-tool="4">
            <span class="swatch swatch-4"></span> Draw Slot 4 (Green)
        </button>
        <button class="tool-button" data-tool="5">
            <span class="swatch swatch-5"></span> Draw Slot 5 (Purple)
        </button>
        <button class="tool-button" data-tool="6">
            <span class="swatch swatch-6"></span> Draw Slot 6 (Yellow)
        </button>
        <button class="tool-button" data-tool="7">
            <span class="swatch swatch-7"></span> Draw Slot 7 (Orange)
        </button>
        <button class="tool-button" data-tool="0">
            <span class="swatch" style="background-color: var(--empty-color);"></span> Eraser (Empty)
        </button>
    </div>
    </div>

    <div id="grid-wrapper">
        <div id="grid-container">
            </div>
        <div id="resize-br" class="resize-handle"></div>
        <div id="resize-tl" class="resize-handle"></div>
    </div>

    <div class="action-buttons">
        <button onclick="convertToSlack()">Generate Slack Message</button>
        <button onclick="pasteToGrid()" class="paste-button">Paste Slack Message to Grid</button>
        <button onclick="clearGrid()" class="clear-button">Clear Canvas</button>
    </div>

    <div id="output-area">
        <label for="slack-message-output">Slack Message Output (Copy & Paste this!)</label>
        <textarea id="slack-message-output" readonly></textarea>
        <button class="copy-button" onclick="copyToClipboard()">Copy to Clipboard</button>
    </div>
</div>

<script>
    const gridWrapper = document.getElementById('grid-wrapper');
    const gridContainer = document.getElementById('grid-container');
    const resizeHandleBR = document.getElementById('resize-br'); // Bottom-Right
    const resizeHandleTL = document.getElementById('resize-tl'); // Top-Left
    const controls = document.querySelector('.controls');
    const toolSelector = document.getElementById('tool-selector');

    const rowSizeInput = document.getElementById('row-size');
    const colSizeInput = document.getElementById('col-size');
    const outputTextArea = document.getElementById('slack-message-output');

    // Core dimensions
    let R_current = 8; 
    let C_current = 12;
    const CELL_DIMENSION = 30; 
    const GAP_SIZE = 1; // From CSS gap property

    // Drawing state
    let isDrawing = false; 
    let activeTool = "1"; // Currently selected tool/color slot (1-4 for drawing, 0 for erase)
    let paintMode = true; 

    // Resizing state
    let isResizing = false;
    let resizeHandleMode = ''; // 'br' for bottom-right, 'tl' for top-left
    let gridInitialRect; // Stores bounding rect of grid at start of resize
    let mouseInitialX = 0;
    let mouseInitialY = 0;

    // Initial grid generation
    generateGrid();
    
    // --- Tool Selector Logic ---
    toolSelector.addEventListener('click', (e) => {
        const button = e.target.closest('.tool-button');
        if (button) {
            activeTool = button.dataset.tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        }
    });

    /* ----------------------------------
     * 1. Drawing Logic (Drag-to-Draw)
     * ---------------------------------- */

    gridContainer.addEventListener('mousedown', (e) => {
        if (isResizing) return;
        if (e.target.classList.contains('cell')) {
            isDrawing = true;
            const cellColorSlot = e.target.getAttribute('data-color-slot');
            if (activeTool === "0") {
                paintMode = false; // Always erase if eraser is active
            } else {
                // If cell is currently empty OR has a different color, we draw. Otherwise, we erase.
                paintMode = (cellColorSlot !== activeTool);
            }
            drawCell(e.target);
        }
    });

    gridContainer.addEventListener('mouseover', (e) => {
        if (isDrawing && e.target.classList.contains('cell')) {
            drawCell(e.target);
        }
    });

    document.addEventListener('mouseup', () => {
        isDrawing = false;
    });

    function drawCell(cell) {
        if (activeTool === "0" || !paintMode) {
            cell.removeAttribute('data-color-slot');
        } else {
            cell.setAttribute('data-color-slot', activeTool);
        }
    }

    /* ----------------------------------
     * 2. Resizing Logic (Drag Handles)
     * ---------------------------------- */

    resizeHandleBR.addEventListener('mousedown', (e) => startResize(e, 'br'));
    resizeHandleTL.addEventListener('mousedown', (e) => startResize(e, 'tl'));

    function startResize(e, mode) {
        e.preventDefault(); 
        isResizing = true;
        resizeHandleMode = mode;
        
        gridInitialRect = gridContainer.getBoundingClientRect(); // Get current size and position
        mouseInitialX = e.clientX;
        mouseInitialY = e.clientY;

        controls.classList.add('resizing');
        document.addEventListener('mousemove', handleResizeMouseMove);
        document.addEventListener('mouseup', handleResizeMouseUp);
    }

    function handleResizeMouseMove(e) {
        if (!isResizing) return;

        let newCols = C_current;
        let newRows = R_current;

        if (resizeHandleMode === 'br') {
            // Bottom-Right: Expand/contract from current top-left
            const dx = e.clientX - mouseInitialX;
            const dy = e.clientY - mouseInitialY;

            // Calculate new grid dimensions based on drag distance
            const targetWidth = gridInitialRect.width + dx;
            const targetHeight = gridInitialRect.height + dy;
            
            newCols = Math.max(3, Math.round(targetWidth / (CELL_DIMENSION + GAP_SIZE))); 
            newRows = Math.max(3, Math.round(targetHeight / (CELL_DIMENSION + GAP_SIZE)));
        } 
        else if (resizeHandleMode === 'tl') {
            // Top-Left: Expand/contract towards current bottom-right
            const dx = mouseInitialX - e.clientX; // Inverted for top-left
            const dy = mouseInitialY - e.clientY; // Inverted for top-left
            
            // For top-left, we want to shift the grid and resize.
            // The effective drag distance tells us how many cells to add/remove.
            const deltaCols = Math.round(dx / (CELL_DIMENSION + GAP_SIZE));
            const deltaRows = Math.round(dy / (CELL_DIMENSION + GAP_SIZE));

            newCols = Math.max(3, C_current + deltaCols);
            newRows = Math.max(3, R_current + deltaRows);

            // To avoid rapid resizing/flickering, only update if significant change
            if (Math.abs(deltaCols) < 1 && Math.abs(deltaRows) < 1) return;
        }

        // Only trigger grid regeneration if dimensions actually change
        if (newRows !== R_current || newCols !== C_current) {
            rowSizeInput.value = newRows;
            colSizeInput.value = newCols;
            generateGrid(); // This will preserve the drawing and update R_current, C_current
            
            // After resizing, update mouse initial for continuous drag, especially for TL
            if (resizeHandleMode === 'tl') {
                mouseInitialX = e.clientX;
                mouseInitialY = e.clientY;
            }
        }
    }

    function handleResizeMouseUp() {
        if (!isResizing) return;
        isResizing = false;
        resizeHandleMode = '';
        controls.classList.remove('resizing');
        document.removeEventListener('mousemove', handleResizeMouseMove);
        document.removeEventListener('mouseup', handleResizeMouseUp);
    }

    /* ----------------------------------
     * 3. Grid Management and Conversion
     * ---------------------------------- */
    
    /**
     * Clears all selections from the grid cells.
     */
    function clearGrid() {
        if (!confirm("Are you sure you want to clear the entire canvas?")) {
            return;
        }
        const cells = Array.from(gridContainer.children);
        cells.forEach(cell => {
            cell.removeAttribute('data-color-slot');
        });
    }

    /**
     * Reads the state of the current grid (before resizing).
     * @returns {Array<Array<string>>} A 2D array representing the color slot (1-4, or empty string).
     */
    function getOldGridState() {
        const state = [];
        const cells = Array.from(gridContainer.children);

        if (cells.length === 0) return [];

        for (let r = 0; r < R_current; r++) {
            state[r] = [];
            for (let c = 0; c < C_current; c++) {
                const index = r * C_current + c;
                if (index < cells.length) {
                    state[r][c] = cells[index].getAttribute('data-color-slot') || "";
                } else {
                    state[r][c] = "";
                }
            }
        }
        return state;
    }

    /**
     * Generates the visual grid based on the row and column inputs, preserving the old drawing.
     * This function is now responsible for handling grid shifts when resizing from top-left.
     */
    function generateGrid() {
        const R_new = parseInt(rowSizeInput.value);
        const C_new = parseInt(colSizeInput.value);
        
        const oldState = getOldGridState();

        if (R_new < 3 || C_new < 3 || R_new > 50 || C_new > 50 || isNaN(R_new) || isNaN(C_new)) {
            rowSizeInput.value = R_current;
            colSizeInput.value = C_current;
            return;
        }

        // Calculate shift for old drawing relative to new grid
        let rowShift = 0;
        let colShift = 0;

        if (resizeHandleMode === 'tl') {
            // When resizing from top-left, the grid "moves" relative to its old position.
            // We need to calculate how much it grew/shrunk from the top/left.
            // The number of cells added/removed from the top/left affects the offset.
            rowShift = R_new - R_current;
            colShift = C_new - C_current;
        }

        R_current = R_new; 
        C_current = C_new;

        document.documentElement.style.setProperty('--grid-rows', R_new);
        document.documentElement.style.setProperty('--grid-cols', C_new);

        gridContainer.innerHTML = '';
        
        for (let r = 0; r < R_new; r++) {
            for (let c = 0; c < C_new; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                
                // Map old cell coordinates to new cell coordinates
                const oldR = r - rowShift;
                const oldC = c - colShift;

                let savedColorSlot = "";
                if (oldR >= 0 && oldR < oldState.length && oldC >= 0 && oldC < oldState[oldR].length) {
                    savedColorSlot = oldState[oldR][oldC];
                }
                
                if (savedColorSlot) {
                    cell.setAttribute('data-color-slot', savedColorSlot);
                }

                gridContainer.appendChild(cell);
            }
        }
    }

    /**
     * Converts the current grid drawing into a Slack-formatted message string.
     */
function convertToSlack() {
        // Map the data-color-slot attribute to the actual emoji code input
        const emojiMap = {};
        for (let i = 1; i <= 7; i++) {
            emojiMap[String(i)] = document.getElementById(`filled-emoji-${i}`).value.trim();
        }
        
        const emptyEmoji = document.getElementById('empty-emoji').value.trim();
        
        for (const key in emojiMap) {
            if (emojiMap[key] && (!emojiMap[key].startsWith(':') || !emojiMap[key].endsWith(':'))) {
                 alert(`Please ensure Emoji Slot ${key} has a valid code (e.g., :emoji_name:).`);
                 return;
            }
        }
        if (!emptyEmoji || !emptyEmoji.startsWith(':') || !emptyEmoji.endsWith(':')) {
            alert("Please ensure the Empty Emoji has a valid code (e.g., :white_square:).");
            return;
        }

        let slackMessage = '';
        const cells = Array.from(gridContainer.children);
        
        for (let r = 0; r < R_current; r++) {
            for (let c = 0; c < C_current; c++) {
                const index = r * C_current + c; 
                const cell = cells[index];
                
                const colorSlot = cell.getAttribute('data-color-slot');

                if (colorSlot && emojiMap[colorSlot]) {
                    slackMessage += emojiMap[colorSlot];
                } else {
                    slackMessage += emptyEmoji;
                }
            }
            slackMessage += '\n';
        }

        outputTextArea.value = slackMessage.trimEnd(); 
    }

    /**
     * Parses the text from the output textarea and draws it onto the grid.
     */
    function pasteToGrid() {
        // ... (preamble of the function) ...

        const emojiMapReverse = {}; // To map emoji codes back to color slots
        emojiMapReverse[document.getElementById('empty-emoji').value.trim()] = ""; // Empty string for empty slot

        // Populate reverse map for filled emojis (updated to 7 slots)
        for (let i = 1; i <= 7; i++) {
            const emojiCode = document.getElementById(`filled-emoji-${i}`).value.trim();
            if (emojiCode && emojiCode.startsWith(':') && emojiCode.endsWith(':')) {
                emojiMapReverse[emojiCode] = String(i);
            }
        }
        
        const lines = textToParse.split('\n').filter(line => line.trim() !== '');

        if (lines.length === 0) {
            alert("No valid emoji lines found in the pasted text.");
            return;
        }

        // Determine the dimensions of the pasted art
        const pastedRows = lines.length;
        // The first line's length will be a multiple of the shortest emoji code length (e.g. 5 for :a:)
        // We'll need to smartly parse this by finding the length of the shortest valid emoji.
        // For simplicity, let's assume all emojis have a consistent length OR parse by emoji code.

        // Get emoji lengths for smarter parsing
        const allEmojiCodes = Object.keys(emojiMapReverse);
        const minEmojiLength = Math.min(...allEmojiCodes.map(code => code.length));
        
        let pastedCols = 0;
        if (lines[0]) {
            // Attempt to count columns based on a minimum emoji length
            pastedCols = Math.floor(lines[0].length / minEmojiLength);
        }

        if (pastedCols === 0) {
             alert("Could not determine grid columns from pasted text. Please check emoji formats.");
             return;
        }

        // Update the grid size inputs and regenerate the grid
        rowSizeInput.value = pastedRows;
        colSizeInput.value = pastedCols;
        generateGrid(); // This clears and redraws to the new size

        // Now, populate the grid with the parsed emojis
        const cells = Array.from(gridContainer.children);
        for (let r = 0; r < pastedRows; r++) {
            const line = lines[r];
            for (let c = 0; c < pastedCols; c++) {
                const index = r * pastedCols + c;
                const cell = cells[index];

                let matchedEmojiCode = "";
                let bestMatchLength = 0;

                // Try to match longest emoji codes first to prevent partial matches
                for (const emojiCode of allEmojiCodes.sort((a,b) => b.length - a.length)) {
                    if (line.substring(c * emojiCode.length, (c * emojiCode.length) + emojiCode.length) === emojiCode) {
                        matchedEmojiCode = emojiCode;
                        bestMatchLength = emojiCode.length;
                        break; // Found the best match for this position
                    }
                }
                
                // Fallback: if no explicit emoji code matches for the full block,
                // and if the line length allows, try to match using the minEmojiLength as a block
                // This is less robust but handles cases where the user's input might be slightly off.
                if (!matchedEmojiCode && (c * minEmojiLength + minEmojiLength) <= line.length) {
                    const genericBlock = line.substring(c * minEmojiLength, c * minEmojiLength + minEmojiLength);
                    if (emojiMapReverse[genericBlock] !== undefined) {
                         matchedEmojiCode = genericBlock;
                    }
                }

                if (matchedEmojiCode && emojiMapReverse[matchedEmojiCode] !== undefined) {
                    const colorSlot = emojiMapReverse[matchedEmojiCode];
                    if (colorSlot) { // If it's a non-empty emoji
                        cell.setAttribute('data-color-slot', colorSlot);
                    } else { // It's the empty emoji
                        cell.removeAttribute('data-color-slot');
                    }
                } else {
                    cell.removeAttribute('data-color-slot'); // Default to empty if no match
                }
            }
        }
        alert("Slack message parsed and drawn onto the grid!");
    }


    /**
     * Copies the content of the output textarea to the clipboard.
     */
    function copyToClipboard() {
        const output = document.getElementById('slack-message-output');
        output.select();
        output.setSelectionRange(0, 99999); 

        try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(output.value).then(() => {
                    alert('Slack message copied to clipboard!');
                });
            } else {
                 document.execCommand('copy');
                 alert('Failed to copy. Please manually select and copy the text.');
            }
        } catch (err) {
            console.error('Could not copy text: ', err);
            alert('Failed to copy. Please manually select and copy the text.');
        }
    }
</script>

</body>
</html>